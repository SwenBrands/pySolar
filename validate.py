#!/usr/bin/env python

'''Verifies reanalysis data against AEMET station data, both brought into a comparable and harmonized format using 1. csv2nc.py and 2. get_neighbour.py prior to calling 3. validate.py (i.e. this script).
Author: Swen Brands, brandssf@ifca.unican.es
'''

#load packages
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cf
import os
import pandas as pd
import xskillscore as xs
from math import radians, cos, sin, asin, sqrt #needed to calculate haversine distance
home = os.getenv('HOME')
exec(open('functions_radiation.py').read())
exec(open(home+'/datos/tareas/proyectos/pticlima/seasonal/python/functions_seasonal.py').read())

#set input parameters
model_dataset = 'era5_land'
rundir = home+'/datos/tareas/proyectos/pticlima/pyPTIclima/pySolar' #script directory, you should be there or point to this directory when running these scripts via python
dir_obs = home+'/datos/tareas/proyectos/pticlima/radiation/netcdf' #path to input netcdf files produced with csv2nc.py containg AEMET station data.
dir_mod = dir_obs #path to input netcdf files produced with get_neighbour.py containg nearest neighbour reanalysis or model data.
dir_netcdf = dir_obs #path to outupt netcdf files produced with this script, containing an xarray dataset with all verification results
dir_figs = home+'/datos/tareas/proyectos/pticlima/radiation/figs/validation' #path to output figures file generated by this script
filename_obs = 'rsds_day_aemet_20171201_20221231.nc'
filename_mod = 'rsds_day_'+model_dataset+'_nn_aemet_20171201_20221231.nc'
taryears = [2017,2022] #start and end years used for validation

#months = [[12,1,2],[3,4,5],[6,7,8],[9,10,11]] #list of lists containing single or several months
#months_labels = ['DJF','MAM','JJA','SON']

months = [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12]] #list of lists containing single or several months
months_labels = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre']
variable_h = 'rsds' # "h" stands for "harmonized"; variable name after transformation by 1. csv2nc.py (for AEMET obs) and 2. get_neighbour.py (for reanalysis or model data), applied before running this script.

precision = 'float32' #precision of the variable in the output netCDF files
dpival = 300 #resultion of the output figure in dpi
figformat = 'pdf' #format of the output figures: pdf, png, etc.
colormap = 'Spectral_r'

##EXECUTE ##############################################################
#create output directories ir they do not exist.
if os.path.isdir(dir_netcdf) != True:
    os.makedirs(dir_netcdf)
if os.path.isdir(dir_figs) != True:
    os.makedirs(dir_figs)

years = np.arange(taryears[0],taryears[1]+1)
nc_obs = xr.open_dataset(dir_obs+'/'+filename_obs)
nc_mod = xr.open_dataset(dir_mod+'/'+filename_mod)

##start verification
obs = nc_obs[variable_h]
mod = nc_mod[variable_h]
dates = pd.DatetimeIndex(obs.time.values)

#init numpy array that will contain the monthly validation results at all stations
pearson_r = np.zeros((len(months),obs.shape[1]))
pearson_pval = np.copy(pearson_r)
pearson_pval_effn = np.copy(pearson_r)
spearman_r = np.copy(pearson_r)
spearman_pval = np.copy(pearson_r)
spearman_pval_effn = np.copy(pearson_r)
#fill these arrays with results
for mm in np.arange(len(months)):
    print('INFO: starting validation for '+str(months[mm]))
    month_ind = np.where(np.isin(dates.month,months[mm]))[0]
    obs_m = obs.isel(time=month_ind) #m stands for monthly or several months time series 
    mod_m = mod.isel(time=month_ind)
    ##calculalate hindcast correlation coefficient for the inter-annual seasonal-mean time series (observations vs. ensemble mean) and corresponding p-values based on the effective sample size
    pearson_r[mm,:] = xs.pearson_r(obs_m,mod_m,dim='time',skipna=True).rename('pearson_r')
    pearson_pval[mm,:] = xs.pearson_r_p_value(obs_m,mod_m,dim='time',skipna=True).rename('pearson_pval')
    pearson_pval_effn[mm,:] = xs.pearson_r_eff_p_value(obs_m,mod_m,dim='time',skipna=True).rename('pearson_pval_effn')
    spearman_r[mm,:] = xs.spearman_r(obs,obs,dim='time',skipna=True).rename('spearman_r')
    spearman_pval[mm,:] = xs.spearman_r_p_value(obs_m,mod_m,dim='time',skipna=True).rename('spearman_pval')
    spearman_pval_effn[mm,:] = xs.spearman_r_eff_p_value(obs_m,mod_m,dim='time',skipna=True).rename('spearman_pval_effn')

##pack results of all metrics into a single xarray dataset containing 3d data arrays (seasons x metrics x stations)
##do this by joining separate xarray data arrays obtained from the numpy arrays into a single dataset
pearson_r = xr.DataArray(data=pearson_r, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'pearson_r')
pearson_pval = xr.DataArray(data=pearson_pval, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'pearson_pval')
#pearson_r = xr.DataArray(data=pearson_r, coords = [months_labels,np.arange(obs.shape[1])], dims = ['season','location'],name = 'pearson_r')
#pearson_pval = xr.DataArray(data=pearson_pval, coords = [months_labels,np.arange(obs.shape[1])], dims = ['season','location'],name = 'pearson_pval')
pearson_r.attrs['units'] = 'dimensionless'
pearson_pval.attrs['units'] = 'probability'
results = xr.merge((pearson_r,pearson_pval)) #merge into a single xr dataset

#location attibutes
results.location.attrs['standard_name'] = 'location index'
results.location.attrs['long_name'] = 'index of the station location'
results.location.attrs['altitude_obs'] = obs.location.altitude
results.location.attrs['station_name'] = obs.location.station_name
results.location.attrs['aemet_code'] = obs.location.aemet_code
results.location.attrs['latitude_obs'] = obs.location.latitude
results.location.attrs['longitude_obs'] = obs.location.longitude
results.location.attrs['latitude_nn'] = mod.location.latitude
results.location.attrs['longitude_nn'] = mod.location.longitude
results.location.attrs['altidue_nn'] = mod.location.altitude
results.location.attrs['info'] = 'obs and nn refer to observations and nearest neighbour model or reanalysis data, respectively.'

#season attributes
results.season.attrs['standard_name'] = 'season index'
results.season.attrs['long_name'] = 'index of season'
results.season.attrs['monhts'] = months
results.season.attrs['season_label'] = months_labels

##plot the matrix of daily files (time x location)
fig = plt.figure()
ax = results.pearson_r.plot.pcolormesh(cmap = colormap, x = 'season', y = 'location', vmin = 0, vmax = 1, add_colorbar=False)
ax.axes.set_yticks(results.location.values)
ax.axes.set_yticklabels(results.location.station_name,fontsize=2)
ax.axes.set_xticks(results.season.values)
ax.axes.set_xticklabels(results.season.season_label,fontsize=2, rotation = 45.)
plt.xticks(fontsize=5)
plt.xlabel(None)
cbar = plt.colorbar(ax,shrink=0.5,label=pearson_r.name + ' ('+results.pearson_r.units+')')
if figformat == 'pdf': #needed to account for irregular behaviour with the alpha parameter when plotting a pdf file
   #fig.set_rasterized(True)
   print('Info: There is a problem with the aplha parameter when generating the figure on my local system. Correct this in future versions !')
start_time = str(dates.min()).replace('-','').replace(' ','').replace(':','')[0:-6]
end_time = str(dates.max()).replace('-','').replace(' ','').replace(':','')[0:-6]
savename = dir_figs+'/pearson_r_day_'+model_dataset+'_vs_aemet_'+start_time+'_'+end_time+'.'+figformat
plt.savefig(savename,dpi=dpival)
plt.close('all')

nc_obs.close()
nc_mod.close()
print('INFO: validate.py has been run successfully !')
