#!/usr/bin/env python

'''Verifies reanalysis data against AEMET station data, both brought into a comparable and harmonized format using 1. csv2nc.py and 2. get_neighbour.py prior to calling 3. validate.py (i.e. this script).
Author: Swen Brands, brandssf@ifca.unican.es
'''

#load packages
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cf
import os
import pandas as pd
import xskillscore as xs
from math import radians, cos, sin, asin, sqrt #needed to calculate haversine distance
home = os.getenv('HOME')
exec(open('functions_radiation.py').read())
exec(open(home+'/datos/tareas/proyectos/pticlima/seasonal/python/functions_seasonal.py').read())

#set input parameters
model_dataset = 'era5_land'
rundir = home+'/datos/tareas/proyectos/pticlima/pyPTIclima/pySolar' #script directory, you should be there or point to this directory when running these scripts via python
dir_obs = home+'/datos/tareas/proyectos/pticlima/radiation/netcdf' #path to input netcdf files produced with csv2nc.py containg AEMET station data.
dir_mod = dir_obs #path to input netcdf files produced with get_neighbour.py containg nearest neighbour reanalysis or model data.
dir_netcdf = dir_obs #path to outupt netcdf files produced with this script, containing an xarray dataset with all verification results
dir_figs = home+'/datos/tareas/proyectos/pticlima/radiation/figs/validation' #path to output figures file generated by this script
filename_obs = 'rsds_day_aemet_20171201_20221231.nc'
filename_mod = 'rsds_day_'+model_dataset+'_nn_aemet_20171201_20221230.nc'
taryears = [2017,2022] #start and end years used for validation

#months = [[12,1,2],[3,4,5],[6,7,8],[9,10,11]] #list of lists containing single or several months
#months_labels = ['DJF','MAM','JJA','SON']

months = [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12]] #list of lists containing single or several months
months_labels = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre']
variable_h = 'rsds' # "h" stands for "harmonized"; variable name after transformation by 1. csv2nc.py (for AEMET obs) and 2. get_neighbour.py (for reanalysis or model data), applied before running this script.

precision = 'float32' #precision of the variable in the output netCDF files
dpival = 300 #resultion of the output figure in dpi
figformat = 'pdf' #format of the output figures: pdf, png, etc.
colormap_ascend = 'Spectral_r' #is set in functions_raditation.py as a function of the applied verification measure
colormap_div = 'seismic'

##EXECUTE ##############################################################
#create output directories ir they do not exist.
if os.path.isdir(dir_netcdf) != True:
    os.makedirs(dir_netcdf)
if os.path.isdir(dir_figs) != True:
    os.makedirs(dir_figs)

years = np.arange(taryears[0],taryears[1]+1)
nc_obs = xr.open_dataset(dir_obs+'/'+filename_obs)
nc_mod = xr.open_dataset(dir_mod+'/'+filename_mod)

##retain common dates
obs = nc_obs[variable_h]
mod = nc_mod[variable_h]
dates_obs = pd.DatetimeIndex(obs.time.values)
dates_mod = pd.DatetimeIndex(mod.time.values)
ind_dates_obs = np.where(dates_obs.isin(dates_mod))[0]
ind_dates_mod = np.where(dates_mod.isin(dates_obs))[0]
obs = obs.isel(time=ind_dates_obs)
mod = mod.isel(time=ind_dates_mod)
dates_obs = dates_obs[ind_dates_obs]
dates_mod = dates_mod[ind_dates_mod]
#check whether reanalysis/model dates and observation dates are identical. If yes, use only one date object thereafter (dates)
if np.all(dates_obs.isin(dates_mod)) != True:
    raise Exception('ERROR: Reanalysis/model dates are not identical to the dates of the observations !')
dates = dates_obs
del(dates_obs,dates_mod)

#init numpy array that will contain the monthly validation results at all stations
pearson_r = np.zeros((len(months),obs.shape[1]))
pearson_pval = np.copy(pearson_r)
pearson_pval_effn = np.copy(pearson_r)
spearman_r = np.copy(pearson_r)
spearman_pval = np.copy(pearson_r)
spearman_pval_effn = np.copy(pearson_r)
bias = np.copy(pearson_r)
mae = np.copy(pearson_r)
rmse = np.copy(pearson_r)
#fill these arrays with results
for mm in np.arange(len(months)):
    print('INFO: starting validation for '+str(months[mm]))
    month_ind = np.where(np.isin(dates.month,months[mm]))[0]
    obs_m = obs.isel(time=month_ind) #m stands for monthly or several months time series 
    mod_m = mod.isel(time=month_ind)
    ##calculalate hindcast correlation coefficient for the inter-annual seasonal-mean time series (observations vs. ensemble mean) and corresponding p-values based on the effective sample size
    pearson_r[mm,:] = xs.pearson_r(obs_m,mod_m,dim='time',skipna=True).rename('pearson_r')
    pearson_pval[mm,:] = xs.pearson_r_p_value(obs_m,mod_m,dim='time',skipna=True).rename('pearson_pval')
    pearson_pval_effn[mm,:] = xs.pearson_r_eff_p_value(obs_m,mod_m,dim='time',skipna=True).rename('pearson_pval_effn')
    spearman_r[mm,:] = xs.spearman_r(obs_m,mod_m,dim='time',skipna=True).rename('spearman_r')
    spearman_pval[mm,:] = xs.spearman_r_p_value(obs_m,mod_m,dim='time',skipna=True).rename('spearman_pval')
    spearman_pval_effn[mm,:] = xs.spearman_r_eff_p_value(obs_m,mod_m,dim='time',skipna=True).rename('spearman_pval_effn')
    #calculate bias and rmse values, see https://xskillscore.readthedocs.io/en/stable/quick-start.html
    bias[mm,:] = xs.me(obs_m,mod_m,dim='time',skipna=True).rename('bias') #in xskillscore the bias is referred to as "mean error" (me)
    mae[mm,:] = xs.mae(obs_m,mod_m,dim='time',skipna=True).rename('mae')
    rmse[mm,:] = xs.rmse(obs_m,mod_m,dim='time',skipna=True).rename('rmse')

##pack results of all metrics into a single xarray dataset containing 3d data arrays (seasons x metrics x stations)
##do this by joining separate xarray data arrays obtained from the numpy arrays into a single dataset
pearson_r = xr.DataArray(data=pearson_r, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'pearson_r')
pearson_r.attrs['units'] = 'dimensionless'

pearson_pval_effn = xr.DataArray(data=pearson_pval_effn, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'pearson_pval_effn')
pearson_pval_effn.attrs['units'] = 'probability'

spearman_r = xr.DataArray(data=spearman_r, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'spearman_r')
spearman_r.attrs['units'] = 'dimensionless'

spearman_pval_effn = xr.DataArray(data=spearman_pval_effn, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'spearman_pval_effn')
spearman_pval_effn.attrs['units'] = 'probability'

bias = xr.DataArray(data=bias, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'bias')
bias.attrs['units'] = nc_obs.rsds.units

rmse = xr.DataArray(data=rmse, coords = [np.arange(len(months)),np.arange(obs.shape[1])], dims = ['season','location'],name = 'rmse')
rmse.attrs['units'] = nc_obs.rsds.units

results = xr.merge((bias,rmse,pearson_r,pearson_pval_effn,spearman_r,spearman_pval_effn)) #merge into a single xr dataset

##add location and seasons attibutes
results = add_location_metadata(results,obs,mod)
results = add_season_metadata(results,months,months_labels)

##plot matrices of verification results for the distinct score (x-axis = seasons, y-axis = stations
start_time = str(dates.min()).replace('-','').replace(' ','').replace(':','')[0:-6]
end_time = str(dates.max()).replace('-','').replace(' ','').replace(':','')[0:-6]
savename_pears = dir_figs+'/pearson_r_day_'+model_dataset+'_vs_aemet_'+start_time+'_'+end_time+'.'+figformat
savename_spear = dir_figs+'/spearman_r_day_'+model_dataset+'_vs_aemet_'+start_time+'_'+end_time+'.'+figformat
savename_bias = dir_figs+'/bias_day_'+model_dataset+'_vs_aemet_'+start_time+'_'+end_time+'.'+figformat
savename_rmse = dir_figs+'/rmse_day_'+model_dataset+'_vs_aemet_'+start_time+'_'+end_time+'.'+figformat
plot_pcolormesh(results,'pearson_r',savename_pears,colormap_ascend,dpival)
plot_pcolormesh(results,'spearman_r',savename_spear,colormap_ascend,dpival)
plot_pcolormesh(results,'bias',savename_bias,colormap_div,dpival)
plot_pcolormesh(results,'rmse',savename_rmse,colormap_ascend,dpival)

#close input nc files and produced xr dataset
nc_obs.close()
nc_mod.close()
results.close()
print('INFO: validate.py has been run successfully !')
