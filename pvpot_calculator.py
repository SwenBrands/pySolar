#!/usr/bin/env python

'''Retains reanalysis data at the grid-boxes located nearest to the AEMET station data, that was read-in and ordered by csv2nc.py in a previous working step.
Hourly reanlaysis data is aggregated to daily-mean values as indicated by the <temporal_aggregation> attribute defined below.
Author: Swen Brands, brandssf@ifca.unican.es
'''

#load packages
import numpy as np
import dask
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cf
import os
import pandas as pd
import xskillscore as xs
from math import radians, cos, sin, asin, sqrt #needed to calculate haversine distance
home = os.getenv('HOME')
exec(open('functions_radiation.py').read())
exec(open(home+'/datos/tareas/proyectos/pticlima/seasonal/python/functions_seasonal.py').read())

#set input parameters
model_dataset = 'era5_land'
rundir = home+'/datos/tareas/proyectos/pticlima/pyPTIclima/pySolar' #script directory, you should be there or point to this directory when running these scripts via python
dir_rean = home+'/datos/OBSData/era5_land_disagg' #path to reanalysis data used for calculating the pv index; base directory structure similar to data, will be expanded as a function of the target area (Iberia or Canarias) and year
#dir_netcdf = home+'/datos/tareas/proyectos/pticlima/radiation/results/data/pvpot' #path to output netcdf file generated by this script
dir_netcdf = home+'/datos/OBSData/era5_land_disagg'
taryears = [1980,2022] #start and end years used for validation
variable = ['u10','v10','ssrd','t2m'] #variable names used to calculate pv index, in fixed order!
domain = ['Iberia','Canarias']
hour_label = 'hour' #label of the hourly aggregation
day_label = 'day' #label of the daily aggregation
varname_out = 'pvpot' #variable name of the photovoltaic potential index within the output netcdf file covering the whole <taryears> period. This file is stored in the <dir_netcdf> folder.
corr_radiation = 'no' #correct input global shortwave radiation data; yes or no
solar_constant = 1362. #in W/m2 upper threshold of the global shortwave radiation data, values above this threshold in the dataset are set to this threshold.
darkness = 0. #in W/m2 lower threshold of the global shortwave radiation data, values below this threshold in the dataset are set to this threshold.

precision = 'float32' #precision of the variable in the output netCDF files
dpival = 300 #resultion of the output figure in dpi
figformat = 'pdf' #format of the output figures: pdf, png, etc.
colormap = 'Spectral_r'
compression_level = 1
print_stats = 'no' #print the basic statistics of the inpute and output xr arrays used and generated by this script

##EXECUTE ##############################################################
#define static variables
years = np.arange(taryears[0],taryears[1]+1)
encoding = {varname_out: {'zlib': True, 'complevel': compression_level}}
for do in np.arange(len(domain)):
    #create directory of the output netcdf file if necessary
    dir_netcdf_complete_hour = dir_netcdf+'/'+domain[do]+'/'+hour_label+'/'+varname_out
    dir_netcdf_complete_day = dir_netcdf+'/'+domain[do]+'/'+day_label+'/'+varname_out
    if os.path.isdir(dir_netcdf_complete_hour) != True:
        os.makedirs(dir_netcdf_complete_hour)
    if os.path.isdir(dir_netcdf_complete_day) != True:
        os.makedirs(dir_netcdf_complete_day)
    
    # #currently not used; create auxiliary directory where the yearly pvpot files are stored; add code to delete the auxiliary files in there each time the script is run in future versions.
    # aux_dir = dir_netcdf_complete+'/aux'
    # if os.path.isdir(aux_dir) != True:
        # os.makedirs(aux_dir)

    #create one output file per year containing the index requested in varname_out
    for yy in np.arange(len(years)):
        print('Calculating PV potential for '+str(years[yy])+'...')
        listdir_u10 = get_nc_path(years[yy],domain[do],dir_rean,variable[0])
        listdir_v10 = get_nc_path(years[yy],domain[do],dir_rean,variable[1])
        listdir_ssrd = get_nc_path(years[yy],domain[do],dir_rean,variable[2])
        listdir_t2m = get_nc_path(years[yy],domain[do],dir_rean,variable[3])
        print('The following files will be loaded for the year '+str(years[yy])+' and domain '+domain[do]+'...')
        print(listdir_u10)
        print(listdir_v10)
        print(listdir_ssrd)
        print(listdir_t2m)

        print('Obtaining hourly wind speed from '+variable[0]+' and '+variable[1]+' for the year '+str(years[yy]))
        nc_u10 = xr.open_mfdataset(listdir_u10) #data from ERA5-Land is in m/s as required for pv index calculation; see doi:10.1016/j.energy.2006.12.006
        nc_v10 = xr.open_mfdataset(listdir_v10)
        nc_si10 = np.sqrt(nc_u10[variable[0]]**2 + nc_v10[variable[1]]**2).rename('si10')
        #close u10 and v10 xarray object to save memory
        nc_u10.close()
        nc_v10.close()
        del(nc_u10,nc_v10)
        nc_ssrd = xr.open_mfdataset(listdir_ssrd)
        accum_meta = nc_ssrd[variable[2]].temporal_aggregation_short #take the temporal aggregation metadata from the input file        
        nc_out = nc_ssrd.copy() #make a copy of the input xarray dataset that will be filled with pv index values calcualted below and then stored
        nc_out = nc_out.drop(variable[2]) #drop radiation variable to fill in pv index below
        #nc_ssrd[variable[2]] = nc_ssrd[variable[2]]/3600 #converts ERA5-Land data form hourly accumulation in W/m2 to W/m2 (per second) as required for pv index calculation; see in doi:10.1016/j.energy.2006.12.006
        #nc_ssrd = nc_ssrd[variable[2]]/3600 #converts ERA5-Land data form hourly accumulation in W/m2 to W/m2 (per second) as required for pv index calculation; see in doi:10.1016/j.energy.2006.12.006
        nc_ssrd = nc_ssrd[variable[2]] #conversion was already done <in disagg.py> and is thus no longer needed here

        #optionally correct the radiation data
        if corr_radiation == 'yes':
            print('Raw '+variable[2]+' data is corrected with '+str(solar_constant)+' and '+str(darkness)+' W/m2 threshold values to correct extensively large and slightly negative values in '+model_dataset+', respectively.')
            np_ssrd = nc_ssrd.values
            darkmask = np.where(np_ssrd < darkness)
            sc_mask = np.where(np_ssrd > solar_constant)
            np_ssrd[darkmask] = darkness
            np_ssrd[sc_mask] = solar_constant
            nc_ssrd.values = np_ssrd
        nc_t2m = xr.open_mfdataset(listdir_t2m)
        #nc_t2m[variable[3]] = nc_t2m[variable[3]]-273.15 #convert ERA5-Land data from Kelvin to degrees Celsius
        nc_t2m = nc_t2m[variable[3]]-273.15 #convert ERA5-Land data from Kelvin to degrees Celsius
        #create pandas Datetime indices and retain commmon period
        dates = pd.DatetimeIndex(nc_si10.time.values)
        
        #The input variables are now ready for PV index calculation following doi:10.1016/j.energy.2006.12.006 and 10.1038/ncomms10014
        print('Calculating hourly Photovoltaic Potential Index for the year '+str(years[yy])+' following Chennie et al. 2017, doi:10.1016/j.energy.2006.12.006 and Jerez et al. 2015, doi:10.1038/ncomms10014')
        tcell = nc_t2m*0.943 + nc_ssrd*0.028 - nc_si10*1.528 + 4.3 #as defined in doi:10.1016/j.energy.2006.12.006 on page 1728
        pr = 1 - 0.005 * (tcell - 25) #as defined in doi:10.1016/j.energy.2006.12.006 on page 6, an alternative value for beta = 0.005 is 0.0045, see Crook et al. 2011, doi:10.1039/C1EE01495A 
        pv = pr*nc_ssrd/1000 #as defined in doi:10.1016/j.energy.2006.12.006 on page 6
        pv = pv.rename(varname_out)
        
        #set variable attributes, pv is a xarray data array 
        pv.attrs['standard_name'] = varname_out
        pv.attrs['long_name'] = 'photovoltaic potential index under all-sky conditions'
        pv.attrs['units'] = 'Positive dimensionless'
        if accum_meta == 'forward':
            accumulation_hour = 'hourly accumulated '+accum_meta+', i.e. from h to h+1 with h being the time instant indicated in the time dimension pointing to the start of the accumulation period. Underlying u10, v10 and tas are instantaneous values sampled at h.'
            accumulation_day = 'daily mean of the hourly data accumulated '+accum_meta+', valid for the time period 00 UTC to 24 UTC of day d, with d being indicated in the time dimension.'
        elif accum_meta == 'backward':
            accumuluation_hour = 'hourly accumulated '+accum_meta+', i.e. from h-1 to h with h being the time instant indicated in the time dimension pointing to the start of the accumulation period. Underlying u10, v10 and tas are instantaneous values sampled at h.'
            accumulation_day = 'daily mean of the hourly data accumulated '+accum_meta+', valid for the time period 23 UTC of day d-1 to 23 UTC of day d, with d being indicated in the time dimension.'
        else:
            raise Exception('Error: Unknown entry for <accum_meta> !')
        pv.attrs['temporal_aggregation'] = accumulation_hour
        pv.attrs['dataset'] = model_dataset
        pv.attrs['outlier_correction'] = corr_radiation
        pv.attrs['description'] = 'Photovoltaic potential index describing the cells potential production with respect to the fixed production for of a global downward shortwave radiation of 1000 W/m2. Positive values indicate a better production than this norm.'
        pv.attrs['formulae'] = varname_out+' = pr*ssrd/ssrd_r, where ssrd is the actual (i.e. taken from '+model_dataset+') hourly global downward shortwave radiation at the surface in W/m2, ssrd_r is the respective reference radiation set at 1000 W/m2, with pr = 1 - beta * (tcell - Ta), with tcell = t2m*c1 + ssrd*c2 - si10*c3 + c4; pr is the so-called performance ratio, beta = 0.005 is a temperature coefficient related to the cell material and structure, Ta is the reference air temperature set at 25ÂºC, t2m is the actual hourly surface air temperature in degrees Celsius, si10 is the actual sustained surface wind speed in m/s and c1 = 0.943, c2 = 0.028, c3 = 1.528 and c4 = 4.3 are coefficients that depend on details of the module and mounting that affect heat transfer from the cell, see doi:10.1039/c1ee01495a for more information'
        pv.attrs['cell_material'] = 'This index if valid for monocrystalline silicon solar panels'
        pv.attrs['references'] = 'Chennie et al. 2017, doi:10.1016/j.energy.2006.12.006 and Jerez et al. 2015, doi:10.1038/ncomms10014'
        
        #set global attributes; nc_out is a xarray dataset
        nc_out[varname_out] = pv
        nc_out.attrs['compression_level'] = str(compression_level)
        nc_out.attrs['author'] = 'Swen Brands, brandssf@ifca.unican.es or swen.brands@gmail.com'
        nc_out.attrs['funding'] = 'This research work was funded by the Ministry for the Ecological Transition and the Demographic Challenge (MITECO) and the European Commission NextGenerationEU (Regulation EU 2020/2094), through CSICs Interdisciplinary Thematic Platform Clima (PTI-Clima).'
        start_date = str(pv.time.values[0]).replace('-','').replace(':','')[0:-14]
        end_date = str(pv.time.values[-1]).replace('-','').replace(':','')[0:-14]
        savename_hour = dir_netcdf_complete_hour+'/'+varname_out+'_'+hour_label+'_'+model_dataset+'_'+domain[do]+'_'+start_date+'_'+end_date+'.nc'
        nc_out.to_netcdf(savename_hour,encoding=encoding)
        
        #calculate daily mean values, print basic statistics and save
        nc_out_day = nc_out.resample(time="24H").mean()
        nc_out_day[varname_out].attrs['temporal_aggregation'] = accumulation_day
        start_date = str(nc_out_day.time.values[0]).replace('-','').replace(':','')[0:-14]
        end_date = str(nc_out_day.time.values[-1]).replace('-','').replace(':','')[0:-14]
        savename_day = dir_netcdf_complete_day+'/'+varname_out+'_'+day_label+'_'+model_dataset+'_'+domain[do]+'_'+start_date+'_'+end_date+'.nc'
        nc_out_day.to_netcdf(savename_day,encoding=encoding)
        
        #optionally print the basic statistic of the input and output xr arrays
        if print_stats == 'yes':
            print_array_stats(nc_ssrd,'The basis statistics for '+hour_label+' '+variable[2]+' data from '+model_dataset+' in '+str(years[yy])+' over '+domain[do]+' are:')
            print_array_stats(pv,'The basis statistics for '+hour_label+' '+varname_out+' data from '+model_dataset+' in '+str(years[yy])+' over '+domain[do]+' are:')
            print_array_stats(nc_out_day[varname_out],'The basis statistics for '+day_label+' '+varname_out+' data from '+model_dataset+' in '+str(years[yy])+' over '+domain[do]+' are:')
        
        #close and delete all loop-wise xarray objects
        nc_si10.close()
        nc_ssrd.close()
        nc_t2m.close()
        pv.close()
        nc_out.close()
        nc_out_day.close()
        del(nc_si10,nc_ssrd,nc_t2m,pv,nc_out,nc_out_day)

    print('The output files for '+varname_out+' from '+model_dataset+' over the '+domain[do]+' domain and period '+str(years[0])+' to '+str(years[-1])+' have been stored in '+dir_netcdf+'/'+domain[do])
print('INFO: pvpot_calculator.py has been run successfully!')
