#!/usr/bin/env python

'''Plots basic time series aspcets of the dataset and variable indicated in <dataset> and variable.
Author: Swen Brands, brandssf@ifca.unican.es
'''

#load packages
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cf
import os
import pandas as pd
import xskillscore as xs
from math import radians, cos, sin, asin, sqrt #needed to calculate haversine distance
home = os.getenv('HOME')
exec(open('functions_radiation.py').read())
exec(open(home+'/datos/tareas/proyectos/pticlima/seasonal/python/functions_seasonal.py').read())

#set input parameters
dataset = 'era5_land'
rundir = home+'/datos/tareas/proyectos/pticlima/pyPTIclima/pySolar' #script directory, you should be there or point to this directory when running these scripts via python
dir_figs = home+'/datos/tareas/proyectos/pticlima/radiation/results/validation' #path to output figures generated by this script
taryears = [2012,2021] #start and end years used for disaggregation
# variable = ['pvpot','tp','ssrd'] #variable names
# domain = ['Iberia','Canarias'] #Iberia or Canarias
# timescale = ['day','hour'] #time-scale or temporal aggregation of the files to be loaded

variable = ['pvpot'] #variable names
domain = ['Iberia'] #Iberia or Canarias
timescale = ['day'] #time-scale or temporal aggregation of the files to be loaded
check_gridboxes = 2 #number of randomly chosen grid-boxes where the results of the joint time-series covering <taryears> will be checked

precision = 'float32' #precision of the variable in the output netCDF files
dpival = 300 #resultion of the output figure in dpi
figformat = 'pdf' #format of the output figures: pdf, png, etc.
colormap = 'Spectral_r'
clean_figdir = 'yes' #clean the figure directory before execution, yes or no
lat_lims = [36,44] #latitudinal limits used for mapping e.g. the climatological mean values
lon_lims = [-10, 5] #longitudinal limits used for mapping e.g. the climatological mean values
cmap_clim = 'turbo' #colormap used to map climatololgical mean values over the target domain
robust_map = True #choose the colormap limits used for mapping so that outliers are not taken into account; True or False

##EXECUTE ##############################################################
os.chdir(rundir) #change path to working directory
years = np.arange(taryears[0],taryears[1]+1) #generate np array of the considered individual years

#loop through domains, variables and timescales
for do in np.arange(len(domain)):
    for vv in np.arange(len(variable)):
        for ti in np.arange(len(timescale)):
            #set directory paths as a function of the dataset and variable
            if dataset == 'era5_land' and variable[vv] in ('ssrd','uas','vas','tas','tp','pvpot'):
                dir_dataset = home+'/datos/OBSData/era5_land_disagg'
                file_style = 'monthly'
            elif dataset == 'era5_land' and variable[vv] == 'dummy': #currently all variables are stored in monthly format, as indicated above
                dir_dataset = home+'/datos/OBSData/era5_land_disagg'
                file_style = 'single'
            else:
                raise Exception('ERROR: Unknown value for <dataset> and/or <variable[vv]> input parameters.')
            
            # if len(years) > 15 and file_style == 'monthly':
                # raise Exception('ERROR: The visualization part of this script is not able to open a very large amount of '+file_style+ ' files with xarray.open_mfdataset(). The script is thus stopped at this point. Please reduce the number of years in <taryears> or set <file_style = "yearly">.')

            dir_figs_complete = dir_figs+'/'+dataset+'/'+domain[do]+'/'+variable[vv]+'/'+timescale[ti]
            
            #create output figure directory if it does not exist
            if os.path.isdir(dir_figs_complete) != True:
                print('Create the times series figure directory at '+dir_figs_complete)
                os.makedirs(dir_figs_complete)
            elif os.path.isdir(dir_figs_complete) == True: #optionally clean the output figure directory if it exists
                if clean_figdir == 'yes':
                        os.chdir(dir_figs_complete)
                        clean_directory_content(dir_figs_complete) #cleans all files in <dir_figs_complete>
                        os.chdir(rundir) #change path to working directory
                elif clean_figdir == 'no':
                    print('As requested by the user, the output figure directory '+dir_figs_complete+' is not cleaned.')
                else:
                    raise Exception('ERROR: unknown entry for the <clean_fig> input parameter !')
            else:
                raise Exception('ERROR: unknown outcome of checking the folder '+dir_figs_complete)

            #load netCDF files; the various temporal aggregations available in disagg.py are also available here
            if file_style == 'yearly': #read all yearly files in <dir_dataset>
                filename_in = dir_dataset+'/'+variable[vv]+'_'+timescale[ti]+'_'+dataset+'_'+domain[do]+'*.nc'
                nc = xr.open_mfdataset(filename_in,autoclose=True)
            elif file_style == 'monthly': #read all monthly files generated by this script, i.e. for the years defined in <taryears> input parameter
                listdir = []
                for yy in np.arange(len(years)):
                    listdir_step = get_nc_path(years[yy],domain[do],dir_dataset,timescale[ti],variable[vv])
                    listdir = np.append(listdir,listdir_step,axis=0)
                nc = xr.open_mfdataset(listdir,autoclose=True)
            elif file_style == 'single': #read a single input file covering all years
                filename_in = dir_dataset+'/'+domain[do]+'/'+timescale[ti]+'/'+variable[vv]+'/'+variable[vv]+'_'+timescale[ti]+'_'+dataset+'_'+domain[do]+'_'+str(years[0])+'0101T00_'+str(years[-1])+'1231T23.nc'
                nc = xr.open_dataset(filename_in)
            else:
                raise Exception('ERROR: Time series plotting options are not yet available for file_style = '+file_style+' !')

            np_var = nc[variable[vv]].values
            notnan = np.where((np.sum(np.isnan(np_var),axis=0)/np_var.shape[0]) != 1)
            del(np_var)
            nc = nc[variable[vv]] #convert xr dataset to data array here
            rand_indices = np.random.randint(0,high=len(notnan[0])-1,size=check_gridboxes)
            print('Plot basic time series aspects for '+variable[vv]+' from '+str(taryears[0])+' to '+str(taryears[1])+' at '+str(check_gridboxes)+' randomly chosen grid-boxes of the '+domain[do]+' domain on '+timescale[ti]+' time-scale...')
            for gb in np.arange(len(rand_indices)):
                val_ind = rand_indices[gb]
                nc_point = nc.isel(latitude=notnan[0][val_ind],longitude=notnan[1][val_ind])
                    
                #plot the hour-to-hour time series at the randomly chosen grid-box
                figure = plt.figure()
                nc_point.plot(linewidth=1.)
                latlabel = str(nc_point.latitude.values).replace('.','_')
                lonlabel = str(nc_point.longitude.values).replace('.','_')
                savename_ts = dir_figs_complete+'/timeseries_'+variable[vv]+'_'+timescale[ti]+'_'+dataset+'_'+domain[do]+'_'+latlabel+'_'+lonlabel+'_'+str(years[0])+'_'+str(years[-1])+'.'+figformat
                plt.savefig(savename_ts,dpi=dpival)
                plt.close('all')

                #plot the climatological mean daily or annual cycle at the randomly chosen grid-box
                if timescale[ti] == 'hour':
                    nc_clim_point = nc_point.groupby('time.hour').mean('time',skipna=True)
                    cyc_label = 'daily_cycle'
                elif timescale[ti] == 'day':
                    nc_clim_point = nc_point.groupby('time.month').mean('time',skipna=True)
                    cyc_label = 'annual_cycle'
                else:
                    raise Exception('ERROR: unknown entry for input parameter <timescale[ti]> !')

                figure = plt.figure()
                nc_clim_point.plot()
                savename_cyc = dir_figs_complete+'/'+cyc_label+'_'+variable[vv]+'_'+timescale[ti]+'_'+dataset+'_'+domain[do]+'_'+latlabel+'_'+lonlabel+'_'+str(years[0])+'_'+str(years[-1])+'.'+figformat
                plt.savefig(savename_cyc,dpi=dpival)
                plt.close('all')
                    
                ##close and delete xarray objects created in this loop that consume memory
                nc_point.close()
                nc_clim_point.close()
                del(nc_point,nc_clim_point)
            
            #plot climatological mean covering the entire loaded time series, cut out the target region and map the results
            nc_clim = nc.mean(dim='time')
            latind = np.where((nc_clim.latitude.values >= lat_lims[0]) & (nc_clim.latitude.values <= lat_lims[1]))[0]
            lonind = np.where((nc_clim.longitude.values >= lon_lims[0]) & (nc_clim.longitude.values <= lon_lims[1]))[0]
            nc_clim = nc_clim.isel(latitude=latind,longitude=lonind)
            nc_clim.attrs['units'] = nc.units
            fig = nc_clim.plot(robust=robust_map,cmap=cmap_clim,subplot_kws=dict(projection=ccrs.LambertConformal(central_longitude = nc_clim.longitude.median().values,central_latitude=nc_clim.latitude.median().values), facecolor="white"),transform=ccrs.PlateCarree(),cbar_kwargs={'orientation':'horizontal','shrink':0.6})
            fig.colorbar.ax.tick_params(labelsize=8) #https://github.com/pydata/xarray/issues/3275
            fig.axes.coastlines()
            fig.axes.add_feature(cf.BORDERS,linewidth=0.5)
            savename_clim = dir_figs_complete+'/clim-mean_'+variable[vv]+'_'+timescale[ti]+'_'+dataset+'_'+domain[do]+'_'+str(years[0])+'_'+str(years[-1])+'.'+figformat
            plt.savefig(savename_clim,dpi=dpival)
            plt.close('all')
            nc_clim.close()
            nc.close()
            del(nc,nc_clim)
        print('INFO: plot_timeseries_aspects.py has been run successfully! The new output netCDF files for '+dataset+', '+variable[vv]+' and times-scale '+timescale[ti]+' have been created in the directory '+dir_figs_complete)
